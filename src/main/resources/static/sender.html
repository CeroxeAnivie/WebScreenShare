<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screen Share Sender</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }
        .container {
            width: 100%;
            max-width: 900px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
        }
        #authSection {
            text-align: center;
            margin-bottom: 20px;
        }
        #passwordInput {
            width: 100%;
            max-width: 300px;
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            box-sizing: border-box;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        #mainSection {
            text-align: center;
        }
        #videoContainer {
            width: 100%;
            max-width: 800px; /* Limit max width */
            margin: 0 auto 20px; /* Center and add bottom margin */
            position: relative;
            overflow: hidden; /* Ensure video doesn't overflow container */
            border-radius: 5px; /* Optional: Match container corners */
        }
        #video {
            width: 100%;
            height: auto; /* Maintain aspect ratio */
            display: block; /* Remove inline spacing */
            background-color: black; /* Black background for video area */
        }
        #status {
            margin-top: 10px;
            font-weight: bold;
            color: #27ae60;
        }
        #stopButton {
            background-color: #e74c3c;
        }
        #stopButton:hover {
            background-color: #c0392b;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>屏幕共享发送端</h1>
    <div id="authSection">
        <label for="passwordInput">输入密码 (留空表示无密码):</label>
        <input type="password" id="passwordInput" placeholder="请输入密码" />
        <button onclick="authenticate()">验证</button>
    </div>
    <div id="mainSection" style="display:none;">
        <div id="videoContainer">
            <video id="video" autoplay muted playsinline></video>
        </div>
        <button id="startButton" onclick="startSharing()">开始共享</button>
        <button id="stopButton" onclick="stopSharing()" disabled>停止共享</button>
        <div id="status">未开始共享</div>
    </div>
</div>

<script>
    let localStream;
    let ws;
    let isAuthenticated = false;
    let sharingActive = false; // Track local sharing state
    let peerConnections = new Map(); // Map to store RTCPeerConnection for each receiver session ID
    let receivedCandidates = new Map(); // Map to store ICE candidates received from receivers before connection is established

    const signalingServerUrl = `ws://${window.location.host}/ws/signaling`;

    async function authenticate() {
        const password = document.getElementById('passwordInput').value; // This can be an empty string
        // No longer check if password is empty here, let the server handle it
        ws = new WebSocket(signalingServerUrl);

        ws.onopen = function(event) {
            console.log('连接到信令服务器');
            // Send initial auth message
            const authMessage = JSON.stringify({
                type: 'auth',
                password: password, // Send the password (or empty string) to server
                role: 'sender'
            });
            ws.send(authMessage);
        };

        ws.onmessage = function(event) {
            const message = JSON.parse(event.data);
            console.log('收到消息:', message); // Debug log
            if (message.type === 'auth_success' && message.role === 'sender') {
                console.log('发送端认证成功');
                isAuthenticated = true;
                document.getElementById('authSection').style.display = 'none';
                document.getElementById('mainSection').style.display = 'block';
            } else if (message.type === 'auth_error') {
                alert('认证失败: ' + message.message);
                ws.close();
            } else if (message.type === 'candidate' && message.receiverId) {
                // Candidate from receiver - includes receiverId
                const receiverId = message.receiverId;
                if (peerConnections.has(receiverId)) {
                    const candidate = new RTCIceCandidate(message.candidate);
                    peerConnections.get(receiverId).addIceCandidate(candidate).catch(e => console.error('为接收端 ' + receiverId + ' 添加候选失败:', e));
                } else {
                    // Store candidate if connection not ready yet
                    if (!receivedCandidates.has(receiverId)) {
                        receivedCandidates.set(receiverId, []);
                    }
                    receivedCandidates.get(receiverId).push(message.candidate);
                    console.log('收到接收端 ' + receiverId + ' 的候选，但连接未就绪。缓存候选。');
                }
            } else if (message.type === 'answer' && message.receiverId) {
                // Answer from receiver - includes receiverId
                const receiverId = message.receiverId;
                if (peerConnections.has(receiverId)) {
                    const answer = new RTCSessionDescription(message.answer);
                    peerConnections.get(receiverId).setRemoteDescription(answer).catch(e => console.error('为接收端 ' + receiverId + ' 设置远程答案失败:', e));
                }
            } else if (message.type === 'receiver_requests_offer') {
                 // Explicit request from a receiver (e.g., page refresh, or new receiver joined and requested)
                 const requestingReceiverId = message.receiverId; // Get the ID of the requesting receiver
                 console.log('收到接收端 ' + requestingReceiverId + ' 的请求Offer消息。共享中?', sharingActive, '本地流?', !!localStream);
                 if (sharingActive && localStream) {
                     console.log('接收端 ' + requestingReceiverId + ' 请求Offer，为其创建Offer。');
                     createAndSendOffer(requestingReceiverId); // Re-send offer to potentially all receivers
                 } else {
                     console.log('收到接收端 ' + requestingReceiverId + ' 的请求，但共享未开始或无流。');
                 }
            }
        };

        ws.onclose = function(event) {
            console.log('信令WebSocket关闭:', event.code, event.reason);
            isAuthenticated = false;
            document.getElementById('authSection').style.display = 'block';
            document.getElementById('mainSection').style.display = 'none';
            document.getElementById('startButton').disabled = false;
            document.getElementById('stopButton').disabled = true;
            document.getElementById('status').textContent = '已断开';
            stopSharing(); // Stop sharing and clean up connections
            sharingActive = false;
        };
    }

    function setupPeerConnection(receiverId) {
        const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }; // Use a STUN server
        const peerConnection = new RTCPeerConnection(configuration);

        peerConnection.onicecandidate = function(event) {
            if (event.candidate && isAuthenticated) {
                // Send candidate to specific receiver
                ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate, receiverId: receiverId }));
            }
        };

        peerConnection.oniceconnectionstatechange = function() {
            console.log('接收端 ' + receiverId + ' 的ICE连接状态:', peerConnection.iceConnectionState);
            // Handle connection state changes if needed
            if (peerConnection.iceConnectionState === 'failed' || peerConnection.iceConnectionState === 'disconnected' || peerConnection.iceConnectionState === 'closed') {
                console.log('接收端 ' + receiverId + ' 的ICE连接失败/断开/关闭。清理连接。');
                cleanupPeerConnection(receiverId);
            }
        };

        peerConnection.onconnectionstatechange = function() {
            console.log('接收端 ' + receiverId + ' 的连接状态:', peerConnection.connectionState);
             if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
                 console.log('接收端 ' + receiverId + ' 的连接失败/断开。清理连接。');
                 cleanupPeerConnection(receiverId);
             }
        };

        // Add local stream tracks to this specific connection
        // --- KEY CHANGE: Add tracks from localStream if available ---
        if (localStream) {
            localStream.getTracks().forEach(track => {
                // Add the original track from localStream to this specific peer connection
                // Pass the localStream as the second argument to associate the track with the stream
                peerConnection.addTrack(track, localStream);
                console.log(`为接收端 ${receiverId} 的PC添加轨道: ${track.kind}`);
            });
        } else {
            console.warn(`为接收端 ${receiverId} 设置PeerConnection时，localStream不可用。`);
        }
        // --- END KEY CHANGE ---

        peerConnections.set(receiverId, peerConnection);
        console.log('为接收端 ' + receiverId + ' 设置新的PeerConnection');
    }

    function cleanupPeerConnection(receiverId) {
        const peerConnection = peerConnections.get(receiverId);
        if (peerConnection) {
             peerConnection.close();
             peerConnection.onicecandidate = null;
             peerConnection.oniceconnectionstatechange = null;
             peerConnection.onconnectionstatechange = null;
             peerConnections.delete(receiverId);
             receivedCandidates.delete(receiverId); // Clean up cached candidates too
             console.log('清理了接收端 ' + receiverId + ' 的PeerConnection');
        }
    }

    async function startSharing() {
        if (!isAuthenticated) {
             alert('请先认证。');
             return;
        }
        if (sharingActive) {
             console.log('共享已在进行中。');
             return; // Prevent multiple start attempts
        }

        // Check if getDisplayMedia is available
        if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
             alert("无法开始屏幕共享: 浏览器不支持 getDisplayMedia API，或者当前环境不安全 (需要 HTTPS 或 localhost)。");
             console.error("getDisplayMedia not available. Check browser compatibility and security context (HTTPS/localhost).");
             return;
        }

        try {
            // --- ENHANCED AUDIO CONSTRAINTS ---
            // Request audio explicitly. Some browsers might need specific settings.
            const constraints = {
                video: true,
                audio: {
                    // Common settings to improve audio capture chances
                    echoCancellation: false, // Often recommended for screen share audio
                    noiseSuppression: false,
                    autoGainControl: false,
                    // channelCount: 2, // Request stereo if available
                    // sampleRate: 48000, // Request a common sample rate
                }
            };
            // --- END ENHANCED AUDIO CONSTRAINTS ---

            localStream = await navigator.mediaDevices.getDisplayMedia(constraints);
            document.getElementById('video').srcObject = localStream;

            sharingActive = true; // Set local state
            document.getElementById('startButton').disabled = true;
            document.getElementById('stopButton').disabled = false;
            document.getElementById('status').textContent = '正在共享...';

            // Send start_share message to signaling server
            ws.send(JSON.stringify({ type: 'start_share' }));

            // --- ENHANCEMENT: Proactively create offers for existing receivers ---
            // This helps if receivers connected *before* sharing started and requested an offer.
            console.log("共享已开始，为已连接的接收端触发 Offer 创建...");
            setTimeout(() => { // Slight delay to ensure server state sync
                 peerConnections.forEach((pc, receiverId) => {
                     console.log(`为已存在的接收端 ${receiverId} 创建 Offer...`);
                     createAndSendOffer(receiverId); // This will create/setup the connection if needed and add tracks
                 });
            }, 100); // 100ms delay

        } catch (err) {
            console.error("开始屏幕共享失败: ", err);
            let errorMessage = "无法开始屏幕共享: ";
            if (err.name === 'NotAllowedError') {
                 errorMessage += "用户拒绝了屏幕共享请求。请确保在弹出窗口中选择了要共享的屏幕/窗口，并根据需要勾选‘共享音频’。";
            } else if (err.name === 'NotFoundError') {
                 errorMessage += "未找到可用的屏幕、窗口或标签页。";
            } else if (err.name === 'NotReadableError') {
                 errorMessage += "操作系统或浏览器阻止了屏幕共享。可能没有给予浏览器录制屏幕的权限。";
            } else if (err.name === 'AbortError') {
                 errorMessage += "屏幕共享被中止。";
            } else {
                 errorMessage += err.message || "未知错误。";
            }
            alert(errorMessage);
            sharingActive = false; // Reset state on failure
            document.getElementById('startButton').disabled = false;
            document.getElementById('stopButton').disabled = true;
            document.getElementById('status').textContent = '未共享';
        }
    }

    // Function to create and send offer to a specific receiver
    // --- ENHANCED: Ensures connection exists and tracks are added ---
    async function createAndSendOffer(receiverId) {
        if (!localStream) {
             console.error('无法为接收端 ' + receiverId + ' 创建Offer: 无本地流。');
             return;
        }
        // Ensure peer connection exists
        if (!peerConnections.has(receiverId)) {
             console.log('接收端 ' + receiverId + ' 无PeerConnection。设置新连接。');
             setupPeerConnection(receiverId); // Create the connection if it doesn't exist
             // setupPeerConnection now handles adding tracks
        } else {
             // If connection exists, ensure tracks are added (idempotent operation)
             const pc = peerConnections.get(receiverId);
             const senders = pc.getSenders();
             localStream.getTracks().forEach(track => {
                 // Check if track is already added to avoid duplicates
                 if (!senders.some(sender => sender.track === track)) {
                     pc.addTrack(track, localStream); // Add track with stream association
                     console.log(`为接收端 ${receiverId} 的PC添加轨道 (createAndSendOffer): ${track.kind}`);
                 }
             });
        }
        try {
             const peerConnection = peerConnections.get(receiverId);
             const offer = await peerConnection.createOffer();
             await peerConnection.setLocalDescription(offer);
             // Send offer to specific receiver
             ws.send(JSON.stringify({ type: 'offer', offer: offer, receiverId: receiverId }));
             console.log('为接收端 ' + receiverId + ' 创建并发送Offer');

             // Process any cached candidates for this receiver
             if (receivedCandidates.has(receiverId)) {
                 const cachedCandidates = receivedCandidates.get(receiverId);
                 console.log('处理接收端 ' + receiverId + ' 的 ' + cachedCandidates.length + ' 个缓存候选');
                 for (const candidateData of cachedCandidates) {
                     const candidate = new RTCIceCandidate(candidateData);
                     peerConnection.addIceCandidate(candidate).catch(e => console.error('为接收端 ' + receiverId + ' 添加缓存候选失败:', e));
                 }
                 receivedCandidates.delete(receiverId); // Clear cache after processing
             }
        } catch (err) {
             console.error('为接收端 ' + receiverId + ' 创建Offer失败:', err);
        }
    }
    // --- END ENHANCED ---

    function stopSharing() {
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            document.getElementById('video').srcObject = null;
            localStream = null;
        }

        // Close all peer connections
        for (let receiverId of peerConnections.keys()) {
            cleanupPeerConnection(receiverId);
        }
        peerConnections.clear();
        receivedCandidates.clear();

        sharingActive = false; // Set local state
        document.getElementById('startButton').disabled = false;
        document.getElementById('stopButton').disabled = true;
        document.getElementById('status').textContent = '未共享';

        // Send stop_share message to signaling server
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'stop_share' }));
        }
    }

</script>
</body>
</html>