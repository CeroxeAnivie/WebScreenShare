<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Screen Share Receiver</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden; /* Hide scrollbars */
            background-color: black; /* Black background */
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #videoContainer {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        #video {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Scale to fit within container, maintaining aspect ratio */
            background-color: black; /* Black background for video element itself */
            /* Make video element itself invisible when no stream */
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        #video.playing {
            opacity: 1;
        }

        /* --- NEW: Auth Section Styles --- */
        #authSection {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8); /* Semi-transparent black overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001; /* High z-index to be on top */
        }
        #authForm {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 90vw; /* Prevent overflow on small screens */
            box-sizing: border-box;
        }
        #passwordInput {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            box-sizing: border-box;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        #authError {
            color: #e74c3c;
            margin-top: 10px;
            font-weight: bold;
        }
        /* --- END NEW --- */

        /* --- NEW: Hover Area and Debug Info Styles --- */
        #debugHoverArea {
            position: fixed;
            top: 0;
            left: 0;
            width: 50px; /* Adjust size as needed */
            height: 50px;
            /* background-color: rgba(255, 0, 0, 0.2); */ /* Optional: visualize hover area during development */
            z-index: 999; /* High z-index to be on top */
            cursor: pointer; /* Indicate it's clickable/hoverable */
        }
        #debugInfo {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000; /* Ensure it's on top */
            display: none; /* Hidden by default */
            max-width: 90vw; /* Prevent overflow on small screens */
            box-sizing: border-box;
        }
        .debug-section {
            margin-bottom: 5px;
        }
        .debug-label {
            font-weight: bold;
        }
        /* --- END NEW --- */
    </style>
</head>
<body>
<!-- --- NEW: Auth Section --- -->
<div id="authSection">
    <div id="authForm">
        <h2>屏幕共享接收端</h2>
        <label for="passwordInput">请输入访问密码:</label>
        <input type="password" id="passwordInput" placeholder="留空表示无密码" />
        <button id="authButton" onclick="authenticate()">验证</button>
        <div id="authError" style="display:none;"></div> <!-- Hidden by default -->
    </div>
</div>
<!-- --- END NEW --- -->

<div id="videoContainer">
    <!-- CRITICAL FIX 1: Ensure NO 'muted' attribute -->
    <video id="video" autoplay playsinline></video>
</div>

<!-- --- NEW: Hover Area and Debug Info Container --- -->
<div id="debugHoverArea"></div>
<div id="debugInfo">
    <div class="debug-section">
        <span class="debug-label">远程流信息:</span>
        <div id="streamInfo">未获取</div>
    </div>
    <div class="debug-section">
        <span class="debug-label">音频轨道状态:</span>
        <div id="audioTrackInfo">无</div>
    </div>
    <div class="debug-section">
        <span class="debug-label">连接状态:</span>
        <div id="connectionInfo">未连接</div>
    </div>
    <div class="debug-section">
        <span class="debug-label">视频元素状态:</span>
        <div id="videoElementInfo">未知</div>
    </div>
</div>
<!-- --- END NEW --- -->

<script>
    let peerConnection;
    let remoteStream;
    let ws;
    let isAuthenticated = false;
    let hasReceivedOffer = false; // Flag to ensure candidates are queued until offer is received
    let candidateQueue = []; // Queue for candidates received before offer
    const signalingServerUrl = `ws://${window.location.host}/ws/signaling`;
    // --- NEW: Debug Mode Toggle & Hover Logic ---
    const DEBUG_MODE = true; // Set to false to completely disable debug features
    let debugHoverTimeout = null; // Timer ID for hiding debug info
    const DEBUG_HOVER_DELAY = 3000; // Milliseconds to wait before hiding after mouse leaves
    // --- END NEW ---

    // --- NEW: Utility function for debug logging ---
    function logDebug(message) {
        if (DEBUG_MODE) {
            console.log("[RECEIVER DEBUG] " + message);
        }
    }

    // --- NEW: Function to update debug information on the page ---
    function updateDebugInfo() {
        if (!DEBUG_MODE) return;

        const streamInfoDiv = document.getElementById('streamInfo');
        const audioTrackInfoDiv = document.getElementById('audioTrackInfo');
        const connectionInfoDiv = document.getElementById('connectionInfo');
        const videoElementInfoDiv = document.getElementById('videoElementInfo');
        const videoElement = document.getElementById('video');

        if (remoteStream) {
            const audioTracks = remoteStream.getAudioTracks();
            const videoTracks = remoteStream.getVideoTracks();
            streamInfoDiv.textContent = `音频轨道: ${audioTracks.length}, 视频轨道: ${videoTracks.length}`;
            if (audioTracks.length > 0) {
                const audioTrack = audioTracks[0];
                // Truncate long IDs for display
                audioTrackInfoDiv.textContent = `ID: ${audioTrack.id.substring(0, 8)}..., 启用: ${audioTrack.enabled}, 状态: ${audioTrack.readyState}`;
            } else {
                audioTrackInfoDiv.textContent = "无音频轨道";
            }
        } else {
            streamInfoDiv.textContent = "未获取";
            audioTrackInfoDiv.textContent = "无";
        }

        if (peerConnection) {
            connectionInfoDiv.textContent = `连接状态: ${peerConnection.connectionState}, ICE状态: ${peerConnection.iceConnectionState}, 信令状态: ${peerConnection.signalingState}`;
        } else {
            connectionInfoDiv.textContent = "无活动连接";
        }

        if (videoElement) {
            // Check element properties
            const rect = videoElement.getBoundingClientRect();
            videoElementInfoDiv.textContent = `尺寸: ${rect.width.toFixed(0)}x${rect.height.toFixed(0)}, 音量: ${videoElement.volume}, 静音: ${videoElement.muted}, 播放状态: ${videoElement.paused ? '暂停' : '播放'}`;
        } else {
            videoElementInfoDiv.textContent = "元素未找到";
        }
    }
    // --- END NEW ---

    // --- NEW: Functions for Hover-based Debug Display ---
    function showDebugInfo() {
        if (DEBUG_MODE) {
            clearTimeout(debugHoverTimeout); // Clear any existing hide timer
            const debugInfo = document.getElementById('debugInfo');
            if (debugInfo) {
                debugInfo.style.display = 'block';
                updateDebugInfo(); // Refresh info when shown
            }
        }
    }

    function scheduleHideDebugInfo() {
        if (DEBUG_MODE) {
            debugHoverTimeout = setTimeout(() => {
                const debugInfo = document.getElementById('debugInfo');
                if (debugInfo) {
                    debugInfo.style.display = 'none';
                }
            }, DEBUG_HOVER_DELAY);
        }
    }

    function setupDebugHoverListeners() {
        if (!DEBUG_MODE) return;

        const hoverArea = document.getElementById('debugHoverArea');
        const debugInfo = document.getElementById('debugInfo');

        if (hoverArea && debugInfo) {
            hoverArea.addEventListener('mouseenter', showDebugInfo);
            hoverArea.addEventListener('mouseleave', scheduleHideDebugInfo);
            debugInfo.addEventListener('mouseenter', showDebugInfo); // Keep it open if mouse moves over the info itself
            debugInfo.addEventListener('mouseleave', scheduleHideDebugInfo);
        }
    }
    // --- END NEW ---

    // --- NEW: Authentication Logic ---
    function authenticate() {
        const passwordInput = document.getElementById('passwordInput');
        const authButton = document.getElementById('authButton');
        const authError = document.getElementById('authError');
        const authSection = document.getElementById('authSection');

        const password = passwordInput.value.trim(); // Get password, trim whitespace

        if (password === "") {
            // Allow empty password input, treat as no password
            console.log("输入了空密码，视为无密码。");
        }

        // Disable button and clear previous error
        authButton.disabled = true;
        authError.style.display = 'none';
        authError.textContent = '';

        // Connect to signaling server
        ws = new WebSocket(signalingServerUrl);

        ws.onopen = function(event) {
            logDebug('连接到信令服务器');
            // Send initial auth message with the entered password (or empty string)
            const authMessage = JSON.stringify({
                type: 'auth',
                password: password, // Send the password (or empty string) to server
                role: 'receiver'
            });
            ws.send(authMessage);
        };

        ws.onmessage = function(event) {
            const message = JSON.parse(event.data);
            logDebug('收到消息:', message); // Debug log
            if (message.type === 'auth_success' && message.role === 'receiver') {
                logDebug('接收端认证成功');
                isAuthenticated = true;
                // Hide auth section and show main section
                authSection.style.display = 'none';
                document.getElementById('videoContainer').style.display = 'flex'; // Ensure video container is displayed
                setupPeerConnection();
                setupDebugHoverListeners(); // Setup hover listeners for debug info
                // After successful auth, explicitly request an offer from the sender
                logDebug('请求来自发送端的Offer。');
                ws.send(JSON.stringify({ type: 'request_offer' }));
            } else if (message.type === 'auth_error') {
                console.error('认证失败:', message.message);
                // Show error message
                authError.textContent = '认证失败: ' + message.message;
                authError.style.display = 'block';
                // Re-enable button
                authButton.disabled = false;
                // Close WebSocket connection
                ws.close();
            } else if (message.type === 'offer' && peerConnection) {
                // Set remote offer FIRST
                const offer = new RTCSessionDescription(message.offer);
                peerConnection.setRemoteDescription(offer).then(() => {
                     logDebug('Offer设置为远程描述。');
                     hasReceivedOffer = true; // Mark that offer is set

                     // Process any queued candidates now that remote description is set
                     processCandidateQueue();
                     // After offer is set, create and send answer
                     return peerConnection.createAnswer();
                }).then(answer => {
                     logDebug('创建Answer。');
                     return peerConnection.setLocalDescription(answer);
                }).then(() => {
                     logDebug('设置本地Answer为本地描述。');
                     // Send answer back to sender, including receiver ID implicitly via session
                     ws.send(JSON.stringify({ type: 'answer', answer: peerConnection.localDescription }));
                     updateDebugInfo(); // Update after setting local desc
                }).catch(e => console.error('设置远程Offer / 创建Answer / 设置本地Answer 错误:', e));
            } else if (message.type === 'candidate' && peerConnection) {
                if (hasReceivedOffer) {
                    // Add candidate immediately if offer is already set
                    const candidate = new RTCIceCandidate(message.candidate);
                    peerConnection.addIceCandidate(candidate).catch(e => console.error('添加候选失败:', e));
                } else {
                    // Queue the candidate if offer hasn't been received yet
                    logDebug('候选收到前Offer，排队。');
                    candidateQueue.push(message.candidate);
                }
            } else if (message.type === 'answer' && peerConnection) {
                // This shouldn't happen on the receiver side, but handle gracefully if needed
                console.warn('在接收端收到Answer，忽略。');
            } else if (message.type === 'sender_started') {
                 document.getElementById('status').textContent = '正在接收流...';
            } else if (message.type === 'sender_stopped') {
                 document.getElementById('status').textContent = '发送端停止。等待...';
                 if (remoteStream) {
                     document.getElementById('video').srcObject = null; // Clear video if stream stops
                     remoteStream = null;
                 }
            }
        };

        ws.onclose = function(event) {
            logDebug('信令WebSocket关闭:', event.code, event.reason);
            isAuthenticated = false;
            // Show auth section again on disconnect
            authSection.style.display = 'flex';
            document.getElementById('videoContainer').style.display = 'none'; // Hide video container
            document.getElementById('status').textContent = '已断开';
             if (remoteStream) {
                 document.getElementById('video').srcObject = null;
                 remoteStream = null;
             }
             if (peerConnection) {
                  peerConnection.close();
                  peerConnection = null;
             }
             // Reset flags and queue on close
             hasReceivedOffer = false;
             candidateQueue = [];
             // Re-enable button
             authButton.disabled = false;
             updateDebugInfo(); // Update debug info on close
        };

        ws.onerror = function(error) {
             console.error("WebSocket 发生错误:", error);
             // Error event often precedes onclose, so we don't need to schedule reconnect here necessarily
             // Let onclose handle the reconnection logic
             // Show error message
             authError.textContent = '连接服务器时发生错误。';
             authError.style.display = 'block';
             // Re-enable button
             authButton.disabled = false;
             updateDebugInfo(); // Update debug info on error
        };
    }
    // --- END NEW ---

    function setupPeerConnection() {
        const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }; // Use a STUN server
        peerConnection = new RTCPeerConnection(configuration);

        peerConnection.onicecandidate = function(event) {
            if (event.candidate && isAuthenticated && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
            }
        };

        peerConnection.ontrack = function(event) {
            logDebug('收到远程轨道');
            // --- CRITICAL FIX 2: Properly handle the remote stream ---
            // The recommended way is to use event.streams[0]
            if (event.streams && event.streams.length > 0) {
                remoteStream = event.streams[0];
                logDebug('使用 event.streams[0] 作为 remoteStream');
            } else {
                // Fallback (less common with modern browsers for screen share)
                logDebug('event.streams 为空，尝试使用 track 创建新流...');
                remoteStream = new MediaStream();
                remoteStream.addTrack(event.track);
            }
            // --- END CRITICAL FIX 2 ---

            const videoElement = document.getElementById('video');
            if (videoElement && remoteStream) {
                logDebug('设置视频源为远程流');
                videoElement.srcObject = remoteStream;

                // --- ENHANCEMENT: Improved Autoplay Handling ---
                // Play the video explicitly (helps with autoplay policies)
                const playPromise = videoElement.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        logDebug("Video play() 成功调用");
                        // Add class to make video visible and play
                        videoElement.classList.add('playing');
                        updateDebugInfo();

                        // --- NEW: Attempt to unmute after successful play ---
                        // This addresses the case where autoplay policy forced mute
                        // and the user might not have interacted to unmute manually.
                        // It's a bit aggressive but often effective if the stream is actually providing audio.
                        if (remoteStream && remoteStream.getAudioTracks().length > 0) {
                            logDebug("尝试在播放成功后取消静音...");
                            videoElement.muted = false;
                            updateDebugInfo();
                            // --- END NEW ---

                        }

                    }).catch(e => {
                        console.warn("Video play() 失败 (可能需要用户手势):", e);
                        if (e.name === "NotAllowedError") {
                            logDebug("尝试静音播放以绕过自动播放策略...");
                            // Mute the video temporarily to comply with autoplay policy
                            videoElement.muted = true; // Ensure muted before play
                            const mutedPlayPromise = videoElement.play();
                            if (mutedPlayPromise !== undefined) {
                                mutedPlayPromise.then(() => {
                                    logDebug("静音状态下 Video play() 成功调用");
                                    videoElement.classList.add('playing');
                                    updateDebugInfo();
                                    // --- NEW: Attempt to unmute even in muted play scenario ---
                                    // Sometimes, the browser allows unmute programmatically after initial play.
                                    // If it fails, it will stay muted until user interacts.
                                    setTimeout(() => {
                                        if (remoteStream && remoteStream.getAudioTracks().length > 0 && videoElement.muted) {
                                            logDebug("尝试在静音播放后取消静音...");
                                            videoElement.muted = false;
                                            updateDebugInfo();
                                        }
                                    }, 500); // Small delay to let things settle
                                    // --- END NEW ---
                                }).catch(mutedError => {
                                    console.error("静音状态下 Video play() 也失败:", mutedError);
                                    updateDebugInfo();
                                });
                            }
                        } else {
                            updateDebugInfo();
                        }
                    });
                }

                updateDebugInfo(); // Update debug info when stream starts
            } else {
                console.error("无法设置视频源: videoElement 或 remoteStream 不存在");
            }
        };


        peerConnection.oniceconnectionstatechange = function() {
            logDebug('ICE连接状态改变:', peerConnection.iceConnectionState);
            updateDebugInfo(); // Update on state change
            if (peerConnection.iceConnectionState === 'failed' || peerConnection.iceConnectionState === 'disconnected' || peerConnection.iceConnectionState === 'closed') {
                console.error('ICE连接失败或断开:', peerConnection.iceConnectionState);
                document.getElementById('status').textContent = '连接失败: ' + peerConnection.iceConnectionState;
            }
        };

        peerConnection.onconnectionstatechange = function() {
             logDebug('连接状态改变:', peerConnection.connectionState);
             updateDebugInfo(); // Update on state change
             if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
                 console.error('连接失败或断开:', peerConnection.connectionState);
                 document.getElementById('status').textContent = '连接失败: ' + peerConnection.connectionState;
             }
             if (peerConnection.connectionState === 'connected' || peerConnection.connectionState === 'completed') {
                 logDebug('ICE连接建立成功。');
             }
        };

         peerConnection.onnegotiationneeded = function() {
             logDebug('需要重新协商 (Negotiation Needed)'); // Might be triggered in some scenarios
             // Implement renegotiation logic if needed (e.g., adding/removing tracks dynamically)
             // For basic screen sharing, this might not be necessary initially.
         };
    }

    // Function to process queued candidates
    function processCandidateQueue() {
         logDebug('处理排队的候选，数量:', candidateQueue.length);
         for (const candidateData of candidateQueue) {
             const candidate = new RTCIceCandidate(candidateData);
             peerConnection.addIceCandidate(candidate).catch(e => console.error('添加排队候选失败:', e));
         }
         candidateQueue = []; // Clear the queue after processing
         updateDebugInfo(); // Update after processing candidates
    }

</script>
</body>
</html>